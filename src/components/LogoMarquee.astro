---
import type { CollectionEntry } from 'astro:content';
import ClientCard from './ClientCard.astro';

type Client = CollectionEntry<'site'>['data']['clients'][number];

interface Props {
  clients?: Client[];
}

const { clients = [] } = Astro.props;

// Fisher-Yates shuffle for randomized order on each page load
const shuffledClients = [...clients].sort(() => Math.random() - 0.5);
---

<!-- Mobile: Swipeable carousel -->
<section class="animate-fade-in-up relative md:hidden overflow-hidden" style="--delay: 350ms;">
  <div id="mobile-carousel-viewport" class="overflow-hidden px-4 pb-4">
    <div id="mobile-carousel-container" class="flex gap-4">
      {shuffledClients.map((client) => (
        <ClientCard
          name={client.name}
          description={client.description}
          logoSrc={client.logoSrc}
        />
      ))}
    </div>
  </div>

  <!-- Pagination dots -->
  <div id="mobile-carousel-dots" class="flex justify-center gap-0">
    {shuffledClients.map((_, index) => (
      <button
        type="button"
        aria-label={`Go to slide ${index + 1}`}
        class="p-1.5 cursor-pointer group"
        data-dot={index}
      >
        <span
          class:list={[
            'block size-2.5 rounded-full transition-colors group-hover:bg-white/50',
            index === 0 ? 'bg-white' : 'bg-white/20',
          ]}
        />
      </button>
    ))}
  </div>
</section>

<!-- Desktop: Bare logos with descriptions, alpha mask edges -->
<section class="hidden md:block relative overflow-hidden desktop-marquee-mask md:-mx-10 shrink-0">
  <h2 class="sr-only">Some of our Clients</h2>
  <div id="marquee-track" class="marquee-track flex items-start gap-24 py-24">
    {[0, 1].map((setIndex) => (
      <div class="marquee-content flex items-start gap-24" aria-hidden={setIndex === 1 ? "true" : undefined}>
        {clients.map((client, index) => (
          <div
            class:list={[
              'flex flex-col items-center w-[270px]',
              setIndex === 0 ? 'animate-fade-in-up' : ''
            ]}
            style={setIndex === 0 ? `--delay: ${350 + index * 100}ms` : ''}
          >
            <div class="h-20 flex items-center justify-center">
              <img
                src={client.logoSrc}
                alt={client.name}
                style={`height: ${client.logoHeight || 80}px`}
                class="w-auto max-w-full object-contain"
              />
            </div>
            <p class="mt-6 text-[14px] text-white/70 text-center tracking-[-0.14px] leading-normal">
              {client.description}
            </p>
          </div>
        ))}
      </div>
    ))}
  </div>
</section>

<style>
  .marquee-track {
    will-change: transform;
  }

  .desktop-marquee-mask {
    -webkit-mask-image: linear-gradient(to right, transparent, black 172px, black calc(100% - 172px), transparent);
    mask-image: linear-gradient(to right, transparent, black 172px, black calc(100% - 172px), transparent);
  }
</style>

<script>
  import EmblaCarousel from 'embla-carousel';

  function initMarquee() {
    // Mobile carousel with Embla
    const viewport = document.getElementById('mobile-carousel-viewport');
    const dotsContainer = document.getElementById('mobile-carousel-dots');
    const dots = dotsContainer?.querySelectorAll('[data-dot]');

    if (viewport && dots && dots.length > 0) {
      const embla = EmblaCarousel(viewport, {
        containScroll: 'trimSnaps',
        align: 'start',
      });

      const updateDots = () => {
        const selected = embla.selectedScrollSnap();
        dots.forEach((dot, index) => {
          const indicator = dot.querySelector('span');
          if (indicator) {
            indicator.classList.toggle('bg-white', index === selected);
            indicator.classList.toggle('bg-white/20', index !== selected);
          }
        });
      };

      embla.on('select', updateDots);

      dots.forEach((dot) => {
        dot.addEventListener('click', () => {
          const index = Number(dot.getAttribute('data-dot'));
          embla.scrollTo(index);
        });
      });
    }

    // Desktop marquee with JS-calculated animation
    const marqueeTrack = document.getElementById('marquee-track');
    const marqueeContent = marqueeTrack?.querySelector('.marquee-content');
    const desktopSection = marqueeTrack?.closest('section');

    if (marqueeTrack && marqueeContent && desktopSection && window.matchMedia('(min-width: 768px)').matches) {
      const contentWidth = marqueeContent.getBoundingClientRect().width;
      const gap = 74;
      const totalWidth = contentWidth + gap;
      const baseSpeed = 30; // 30px per second (normal)
      const slowSpeed = baseSpeed * 0.75; // 25% slower on hover

      let animationId: number | null = null;
      let position = 0;
      let lastTimestamp: number | null = null;
      let currentSpeed = baseSpeed;
      let targetSpeed = baseSpeed;

      const animate = (timestamp: number) => {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        // Smoothly interpolate speed toward target (ease-out feel)
        const speedDiff = targetSpeed - currentSpeed;
        if (Math.abs(speedDiff) > 0.1) {
          // Lerp with ease-out by using diminishing factor
          currentSpeed += speedDiff * 0.08;
        } else {
          currentSpeed = targetSpeed;
        }

        position += currentSpeed * deltaTime;
        if (position >= totalWidth) {
          position -= totalWidth;
        }

        marqueeTrack.style.transform = `translateX(${-position}px)`;
        animationId = requestAnimationFrame(animate);
      };

      // Check for reduced motion preference
      if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        animationId = requestAnimationFrame(animate);

        // Hover handlers for slowdown
        const handleMouseEnter = () => {
          targetSpeed = slowSpeed;
        };
        const handleMouseLeave = () => {
          targetSpeed = baseSpeed;
        };
        desktopSection.addEventListener('mouseenter', handleMouseEnter);
        desktopSection.addEventListener('mouseleave', handleMouseLeave);

        // Restart animation smoothly when tab regains focus
        const handleVisibility = () => {
          if (document.visibilityState === 'visible') {
            lastTimestamp = null;
          }
        };
        document.addEventListener('visibilitychange', handleVisibility);

        // Cleanup on page swap
        document.addEventListener('astro:before-swap', () => {
          if (animationId) cancelAnimationFrame(animationId);
          document.removeEventListener('visibilitychange', handleVisibility);
          desktopSection.removeEventListener('mouseenter', handleMouseEnter);
          desktopSection.removeEventListener('mouseleave', handleMouseLeave);
        }, { once: true });
      }
    }
  }

  // Run on initial load and after each navigation
  document.addEventListener('astro:page-load', initMarquee);
</script>
