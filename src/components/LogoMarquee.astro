---
import type { CollectionEntry } from 'astro:content';
import ClientCard from './ClientCard.astro';

type Client = CollectionEntry<'site'>['data']['clients'][number];

interface Props {
  clients?: Client[];
}

const { clients = [] } = Astro.props;
---

<!-- Mobile: Swipeable carousel -->
<section class="relative md:hidden overflow-hidden">
  <div
    id="mobile-carousel"
    class="flex gap-4 overflow-x-auto px-4 pb-4 snap-x snap-mandatory scrollbar-hide carousel-elastic"
  >
    {clients.map((client) => (
      <ClientCard
        name={client.name}
        description={client.description}
        logoSrc={client.logoSrc}
      />
    ))}
  </div>

  <!-- Pagination dots -->
  <div class="flex justify-center gap-[7px]">
    {clients.map((_, index) => (
      <button
        type="button"
        aria-label={`Go to slide ${index + 1}`}
        class:list={[
          'size-2.5 rounded-full transition-colors cursor-pointer',
          index === 0 ? 'bg-white' : 'bg-white/20',
        ]}
        data-dot={index}
      />
    ))}
  </div>
</section>

<!-- Desktop: Bare logos with descriptions, alpha mask edges -->
<section class="hidden md:block relative overflow-hidden desktop-marquee-mask">
  <div id="marquee-track" class="marquee-track flex items-start gap-[74px] py-8">
    {[0, 1].map(() => (
      <div class="marquee-content flex items-start gap-[74px]">
        {clients.map((client) => (
          <div class="shrink-0 flex flex-col items-center w-[270px]">
            <div class="h-[80px] flex items-center justify-center">
              <img
                src={client.logoSrc}
                alt={client.name}
                style={`height: ${client.logoHeight || 80}px`}
                class="w-auto max-w-full object-contain"
              />
            </div>
            <p class="mt-6 text-[14px] text-white/70 text-center tracking-[-0.14px] leading-normal">
              {client.description}
            </p>
          </div>
        ))}
      </div>
    ))}
  </div>
</section>

<style>
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  .marquee-track {
    will-change: transform;
  }

  .carousel-elastic {
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .carousel-elastic.dragging {
    transition: none;
  }

  .desktop-marquee-mask {
    -webkit-mask-image: linear-gradient(to right, transparent, black 172px, black calc(100% - 172px), transparent);
    mask-image: linear-gradient(to right, transparent, black 172px, black calc(100% - 172px), transparent);
  }
</style>

<script>
  const carousel = document.getElementById('mobile-carousel');
  const dots = document.querySelectorAll('[data-dot]');
  const cards = carousel?.querySelectorAll(':scope > div');

  if (carousel && dots.length > 0 && cards && cards.length > 0) {
    const cardWidth = (cards[0] as HTMLElement).offsetWidth;
    const gap = 16;

    // Update dots on scroll
    carousel.addEventListener('scroll', () => {
      const scrollLeft = carousel.scrollLeft;
      const activeIndex = Math.round(scrollLeft / (cardWidth + gap));

      dots.forEach((dot, index) => {
        dot.classList.toggle('bg-white', index === activeIndex);
        dot.classList.toggle('bg-white/20', index !== activeIndex);
      });
    });

    // Click dots to scroll to slide
    dots.forEach((dot) => {
      dot.addEventListener('click', () => {
        const index = Number(dot.getAttribute('data-dot'));
        const scrollPosition = index * (cardWidth + gap);
        carousel.scrollTo({ left: scrollPosition, behavior: 'smooth' });
      });
    });

    // Elastic overscroll effect
    let touchStartX = 0;
    let elasticOffset = 0;
    const maxElastic = 80;
    const resistance = 0.4;

    carousel.addEventListener('touchstart', (e) => {
      touchStartX = e.touches[0].clientX;
      carousel.classList.add('dragging');
    }, { passive: true });

    carousel.addEventListener('touchmove', (e) => {
      const touchX = e.touches[0].clientX;
      const diff = touchX - touchStartX;
      const maxScroll = carousel.scrollWidth - carousel.clientWidth;

      // At left edge, pulling right
      if (carousel.scrollLeft <= 0 && diff > 0) {
        elasticOffset = Math.min(diff * resistance, maxElastic);
        carousel.style.transform = `translateX(${elasticOffset}px)`;
      }
      // At right edge, pulling left
      else if (carousel.scrollLeft >= maxScroll && diff < 0) {
        elasticOffset = Math.max(diff * resistance, -maxElastic);
        carousel.style.transform = `translateX(${elasticOffset}px)`;
      }
      else {
        elasticOffset = 0;
        carousel.style.transform = '';
      }
    }, { passive: true });

    carousel.addEventListener('touchend', () => {
      carousel.classList.remove('dragging');
      carousel.style.transform = '';
      elasticOffset = 0;
    });
  }

  // Desktop marquee with JS-calculated animation
  const marqueeTrack = document.getElementById('marquee-track');
  const marqueeContent = marqueeTrack?.querySelector('.marquee-content');

  if (marqueeTrack && marqueeContent && window.matchMedia('(min-width: 768px)').matches) {
    const contentWidth = marqueeContent.getBoundingClientRect().width;
    const gap = 74;
    const totalWidth = contentWidth + gap;
    const duration = totalWidth / 50; // 50px per second

    // Use requestAnimationFrame for smoother animation
    let startTime: number | null = null;

    const animate = (timestamp: number) => {
      if (!startTime) startTime = timestamp;
      const elapsed = timestamp - startTime;
      const progress = (elapsed / (duration * 1000)) % 1;
      const translateX = -progress * totalWidth;

      marqueeTrack.style.transform = `translateX(${translateX}px)`;
      requestAnimationFrame(animate);
    };

    // Check for reduced motion preference
    if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      requestAnimationFrame(animate);
    }
  }
</script>
